<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JS Promises</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<style>
em {
	color: #47fcff;
}

.reveal a {
	color: #32E875;
}

.reveal code {
	color: #47fcff;
}

.reveal pre code {
	color: #ddd;
}
		</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section data-markdown>
					<textarea data-template>
						## Promises in JavaScript

						or:

						Do this, then that.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Who am I?

						ðŸ‘‹ I'm Payton. I write code at Automattic, makers of WordPress.com.

						<small>I also like tea, Tai Chi, and Dungeons and Dragons.</small>

						<small>https://payton.codes/</small>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### How does JavaScript execute code?

						JavaScript is <em>single-threaded</em>; it only executes one thing at a time.

						<p class="fragment">But it is also <em>asynchronous</em>; it is designed to react to events and to trigger jobs that take an unknown amount of time to complete.</p>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### The Event Loop

						JavaScript executes statements in the current block until they are all complete.

						<p class="fragment">Then it loops back around and checks for new statements in the queue.</p>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### The Event Queue

						Some things that can add to the queue:

						- user events (clicks, typing, etc.)
						- browser events (loading, leaving, etc.)
						- network events
						- data events
						- the `setTimeout()` function
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Callbacks

						We can add a block of code to the queue that will be executed when an event occurs. This is a callback function.

						<pre><code data-trim data-noescape>
							document.addEventListener('DOMContentLoaded', function() {
								console.log('The page is ready!');
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						But what if you want to chain multiple callbacks together?

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle(); // wait until it's finished, then...
							boilWater(); // wait until it's finished, then...
							addLeaves('green'); // wait until it's finished, then...
							steepTea('1 minute');
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Let's try using callbacks.

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle(function() {
								boilWater(function() {
									addLeaves('green', function() {
										steepTea('1 minute');
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Callback Hell!

						<pre><code data-trim class="JavaScript">
							fillKettle(function() {
								boilWater(function() {
									addLeaves('green', function() {
										steepTea('1 minute', function() {
											pourTea(function() {
                        serveTea(function() {
                          drinkTea();
                        });
											});
										});
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Promises

						Promises are the solution to callback hell.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						> The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Each `Promise` object has a `then()` method that accepts a callback. The callback will be called when the operation is complete.

						<pre><code data-trim data-noescape class="JavaScript">
							doThis().then(doThat);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`then()` always returns a Promise, so we can chain them together.

						<pre><code data-trim data-noescape class="JavaScript">
							doThis().then(doThat).then(doSomethingElse);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Here's that callback code again:

						<small>(Switched to fat arrow functions)</small>

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle(() => {
								boilWater(() => {
									addLeaves('green', () => {
										steepTea('1 minute');
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Let's try again using Promises.

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle()
							.then(boilWater)
							.then(() => addLeaves('green'))
							.then(() => steepTea('1 minute'));
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Remember this?

						<pre><code data-trim class="JavaScript">
							fillKettle(function() {
								boilWater(function() {
									addLeaves('green', function() {
										steepTea('1 minute', function() {
											pourTea(function() {
                        serveTea(function() {
                          drinkTea();
                        });
											});
										});
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						It doesn't matter how many callbacks we need, there's no nesting.

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle()
							.then(boilWater)
							.then(() => addLeaves('green'))
							.then(() => steepTea('1 minute'))
							.then(pourTea)
							.then(serveTea)
							.then(drinkTea);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`then()` always returns a `Promise` object. If the callback does not return a Promise, its return value is converted into a Promise automatically.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Creating Promises

						`Promise` is a top-level object.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise();
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						The Promise constructor function takes one argument, which is a callback to run asynchronously.

						When the callback is done, it should call `resolve()` or `reject()`, which are arguments to the callback.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise(function (resolve, reject) {
								setTimeout(function() {
									resolve();
								}, 1000) // Takes 1 second to resolve
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Any `then()` callbacks will be called when `resolve()` is called inside the Promise function.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise(function (resolve, reject) {
								setTimeout(function() {
									resolve();
								}, 1000) // Takes 1 second to resolve
							});

							myPromise.then(() => console.log('all done!'));
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						If `resolve()` is passed arguments, those arguments are provided to the callback in `then()`.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise(function (resolve, reject) {
								setTimeout(function() {
									resolve('Hong Shui Oolong');
								}, 1000) // Takes 1 second to resolve
							});

							myPromise.then(tea => console.log(`Today's tea is ${tea}`));
						</code></pre>

						<pre><code data-trim data-noescape class="markdown">
							Today's tea is Hong Shui Oolong
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### fetch

						`fetch()` is a Web API function in JavaScript that makes HTTP requests.

						It returns a `Promise` that resolves when the request is complete.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### fetch

						The result of `fetch()` must be converted to something (like JSON) before it can be used. This process also returns a `Promise`.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Using `fetch()` to get JSON data from a web server:

						<pre><code data-trim data-noescape class="JavaScript">
							fetch('https://jsonplaceholder.typicode.com/todos/1')
							.then(response => response.json())
							.then(json => console.log(json))
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape class="json">
{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
						</code></pre>
					</textarea>
				</section>

			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
