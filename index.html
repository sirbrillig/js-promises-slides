<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>JS Promises</title>

		<link rel="stylesheet" href="css/reset.css">
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/monokai.css">

		<style>
em {
	color: #47fcff;
}

.reveal a {
	color: #32E875;
}

.reveal code {
	color: #47fcff;
}

.reveal pre code {
	color: #ddd;
}
		</style>

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section data-markdown>
					<textarea data-template>
						## Promises in JavaScript

						or:

						Do this, then that.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Who am I?

						ðŸ‘‹ I'm Payton. I write code at Automattic, makers of WordPress.com.

						<small>I also like tea, Tai Chi, and Dungeons and Dragons.</small>

						<small>https://payton.codes/</small>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### How does JavaScript execute code?

						JavaScript is <em>single-threaded</em>; it only executes one thing at a time.

						<p class="fragment">But it is also <em>asynchronous</em>; it is designed to react to events and to trigger jobs that take an unknown amount of time to complete.</p>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### The Event Loop

						JavaScript executes statements in the current block until they are all complete.

						<p class="fragment">Then it loops back around and checks for new statements in the queue.</p>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### The Event Queue

						Some things that can add to the queue:

						- user events (clicks, typing, etc.)
						- browser events (loading, leaving, etc.)
						- network events
						- data events
						- the `setTimeout()` function
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Callbacks

						We can add a block of code to the queue that will be executed when an event occurs. This is a callback function.

						<pre><code data-trim data-noescape>
							document.addEventListener('DOMContentLoaded', function() {
								console.log('The page is ready!');
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						But what if you want to chain multiple callbacks together?

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle(); // wait until it's finished, then...
							boilWater(); // wait until it's finished, then...
							addLeaves('green'); // wait until it's finished, then...
							steepTea('1 minute');
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Let's try using callbacks.

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle(function() {
								boilWater(function() {
									addLeaves('green', function() {
										steepTea('1 minute');
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Callback Hell!

						<pre><code data-trim class="JavaScript">
							fillKettle(function() {
								boilWater(function() {
									addLeaves('green', function() {
										steepTea('1 minute', function() {
											pourTea(function() {
                        serveTea(function() {
                          drinkTea();
                        });
											});
										});
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Promises

						Promises are the solution to callback hell.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						> The Promise object represents the eventual completion (or failure) of an asynchronous operation, and its resulting value.

						<small>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</small>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						A Promise is in one of these states:

						- _pending_: initial state, neither fulfilled nor rejected.
						- _fulfilled_: meaning that the operation completed successfully.
						- _rejected_: meaning that the operation failed.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Each `Promise` object has a `then()` method that accepts a callback. The callback will be called when the operation is complete.

						<pre><code data-trim data-noescape class="JavaScript">
							doThis().then(doThat);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`then()` always returns a Promise, so we can chain them together.

						<pre><code data-trim data-noescape class="JavaScript">
							doThis().then(doThat).then(doSomethingElse);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						It's easier to read if we put them vertically:

						<pre><code data-trim data-noescape class="JavaScript">
							doThis()
							.then(doThat)
							.then(doSomethingElse);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Here's that callback code again:

						<small>(Switched to fat arrow functions)</small>

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle(() => {
								boilWater(() => {
									addLeaves('green', () => {
										steepTea('1 minute');
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Let's try again using Promises.

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle()
							.then(boilWater)
							.then(() => addLeaves('green'))
							.then(() => steepTea('1 minute'));
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Remember this?

						<pre><code data-trim class="JavaScript">
							fillKettle(function() {
								boilWater(function() {
									addLeaves('green', function() {
										steepTea('1 minute', function() {
											pourTea(function() {
                        serveTea(function() {
                          drinkTea();
                        });
											});
										});
									});
								});
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						It doesn't matter how many callbacks we need, there's no nesting.

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle()
							.then(boilWater)
							.then(() => addLeaves('green'))
							.then(() => steepTea('1 minute'))
							.then(pourTea)
							.then(serveTea)
							.then(drinkTea);
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`then()` always returns a `Promise` object.

						If the callback does not return a Promise, its return value is converted into a Promise automatically.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Creating Promises

						`Promise` is a top-level constructor function.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise();
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						The Promise constructor function takes one argument, which is a function to run immediately. It should do something asynchronous.

						When it's done, it should call `resolve()` or `reject()`, which are arguments to the function.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise(function (resolve, reject) {
								setTimeout(function() {
									resolve();
								}, 1000) // Takes 1 second to resolve
							});
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Any `then()` callbacks will be called when `resolve()` is called inside the Promise function.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise(function (resolve, reject) {
								setTimeout(function() {
									resolve();
								}, 1000);
							});

							myPromise.then(() => console.log('all done!'));
							console.log('starting operation...');
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape class="markdown">
							starting operation...
							all done!
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						If `resolve()` is passed arguments, those arguments are provided to the callback in `then()`.

						<pre><code data-trim data-noescape class="JavaScript">
							const myPromise = new Promise(function (resolve, reject) {
								setTimeout(function() {
									resolve('Hong Shui Oolong');
								}, 1000) // Takes 1 second to resolve
							});

							myPromise.then(tea => console.log(`Today's tea is ${tea}`));
						</code></pre>

						<pre><code data-trim data-noescape class="markdown">
							Today's tea is Hong Shui Oolong
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### fetch

						`fetch()` is a Web API function in JavaScript that makes HTTP requests.

						It returns a `Promise` that resolves when the request is complete.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### fetch

						The result of `fetch()` must be converted to something (like JSON) before it can be used. This process also returns a `Promise`.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						Using `fetch()` to get JSON data from a web server:

						<pre><code data-trim data-noescape class="JavaScript">
							fetch('https://jsonplaceholder.typicode.com/todos/1')
							.then(response => response.json())
							.then(json => console.log(json))
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape class="json">
{
  "userId": 1,
  "id": 1,
  "title": "delectus aut autem",
  "completed": false
}
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Handling errors

						If a Promise fails, its `reject()` function is called instead of `resolve()`.

						This will cause it to _skip_ all `then()` callbacks and instead call the nearest `catch()`.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Catch

						Every Promise object also has a `catch()` method, which works just like `then()`. It takes one callback argument which is called if the Promise fails.

						<pre><code data-trim data-noescape class="JavaScript">
							boilWater()
							.catch(() => console.error('There was a problem making tea.'))
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`catch()` will be called for any unhandled rejection in any Promise in the chain.

						The following `catch()` is called if any of the steps fails (and the chain will stop):

						<pre><code data-trim data-noescape class="JavaScript">
							fillKettle()
							.then(boilWater)
							.then(() => addLeaves('green'))
							.then(() => steepTea('1 minute'));
							.catch(() => console.error('There was a problem making tea.'))
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`then()` (or `catch()`) will be called even if the Promise has _already_ resolved.

						<pre><code data-trim data-noescape class="JavaScript">
							const done = new Promise(resolve => resolve('hello'))

							done
							.then(greeting => console.log(`${greeting}, my friend!`))
						</code></pre>

						<pre class="fragment"><code data-trim data-noescape class="markdown">
							hello, my friend!
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						There's actually a shortcut for this pattern: `Promise.resolve()`

						<pre><code data-trim data-noescape class="JavaScript">
							const done = Promise.resolve('hello')

							done
							.then(greeting => console.log(`${greeting}, my friend!`))
						</code></pre>
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						### Multiple Promises

						When you want to wait for several Promises to complete, you can use `Promise.all()`.

						It accepts an array of Promises and returns a new Promise that will complete when all the others are complete.
					</textarea>
				</section>

				<section data-markdown>
					<textarea data-template>
						`Promise.all()` is useful to run things in "parallel"*, like loading resources for a game.

						<small>*Async but still serial.</small>

						<pre><code data-trim data-noescape class="JavaScript">
							const imageLoader = loadImages();
							const soundLoader = loadSounds();
							const movieLoader = loadMovies();
							const loader = Promise.all([
								imageLoader,
								soundLoader,
								movieLoader,
							]);

							loader.then(startGame);
						</code></pre>
					</textarea>
				</section>

			</div>
		</div>

		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				hash: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});
		</script>
	</body>
</html>
